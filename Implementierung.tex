\chapter{Implementierung}
\label{chap:Implementierung}

Nach genauerem betrachten der Formel für die dynamische Verlustleistung \ref{eq:dynVerlustleistung} hängt diese von vier Faktoren ab, Schaltaktivitäten,  Lastkapazität, Versorgungsspannung und der Frequenz. Die statische Verlustleistung wird nicht weiter betrachtet, da diese nur durch eine Veränderung der Hardware verbessert werden könnte. Dies ist jedoch nicht Teil dieser Arbeit. Da ebenfalls die Spannung und die Frequenz von der Architektur und anderen nicht beeinflussbaren Faktoren vorgegeben wurde kann auch an diesen Parametern nichts geändert werden. Im folgenden wird nun erst darauf eingegangen wie, durch Minimierung der Schaltaktivitäten, die Verlustleistung optimiert werden kann. Im Weiteren Verlauf des Textes wird dann ebenfalls der Einfluss der Lastkapazitäten überprüft.\\
Um in ein Register zu schreiben, muss eine geeignete Adresse an den Adressbus angelegt werden. Da es sich bei der Architektur um 32-bit-Register handelt muss hierfür eine 5-bit Adresse angelegt werden. Dieser Adressbus wird nun auf Schaltaktivität optimiert. Schreibt beispielsweise eine Anweisung an die Adresse Null und die nachfolgende Instruktion an die Adresse 31, so wäre dies der Worst-Case, da in diesem Fall alle 5-Bit umgeladen werden müssten. Befinden sich im Code jedoch virtuelle Register so können diese an beliebiger Stelle zugewiesen und somit die Adresse frei wählbar machen. Dadurch kann die Schaltaktivitäten der Leitungen verringert werden. Aus diesem Grund wurde zu Beginn eine Heuristik entwickelt bei der die Hammingdistanz der Adressleitungen minimiert wird.
\section{Heuristik}
\label{sec:Heuristik}
Um die Hammingdistanz zu berechnen werden die Adressen der letzten Anweisung gespeichert. Da die Architektur zwei Issue-Slots aufweist und diese auf beide Register-Files zugreifen können muss es dementsprechend vier Target-Adressleitungen geben(siehe Abbildung XXX). Wollen beide Instruktionen an das selbe Register-File schreiben, so werden entweder die alle zehn Adressleitungen für die Adressierung verwendet. Verwenden beiden Instruktionen unterschiedliche Register werden jeweils die unteren fünf Adressleitungen des jeweiligen Registers verwendet. Die Adressen bleiben solange in an der Adressleitung angelegt, bis ein neuer Befehl diese Leitungen benutzen muss. Die Distanz wird nun immer mit den zuletzt verwendeten Adressen bestimmt. 

\section{Genetischer Algorithmus}
\label{sec:genetischerAlgorithmus}
Die Gene des implementierten genetischen Algorithmus wurden so gewählt, dass diese die zu allokierenden Register repräsentieren. Die Anzahl der Gene hängt hierbei jeweils von der Menge der virtuellen Registern ab. Jedes Gen entspricht einem Mapping von virtuellen zu physikalischen Registern.
Die Populationsgröße wurde aus der Literatur [LLL] entnommen. Im Kapitel XXX wird der Einfluss der Population auf die Ergebnisse genauer untersucht. 


\subsection{Fitness-Funktion}
Da die Registerallokation dem Scheduling untergeordnet ist und von diesem aufgerufen wird, muss die Fitnessfunktion an die des Scheduling angepasst werden. Aus diesem Grund wurde zum einfacheren Vorgehen zwei Verschiedene Fitness-Funktionen implementiert. Zum einen der Wert der an die übergeordnete Funktion weitergegeben wird und zum Andern eine interne Fitness um die Ergebnisse zu evaluieren.
Der Übergabewert besteht lediglich aus der Anzahl der Register die nicht im Register-File allokiert werden konnten. Bei der internen Fitness-Funktion wurden mehrere Ansätze evaluiert.
\begin{itemize}
	\item Hamming-Distanz\\
		Als erste Variante wurde die Summe der Hamming-Distanzen als Fitness-Funktion verwendet. Hierzu wurden die Hammingdistanzen der Target- sowie Source-Register ermittelt. Wie im Falle der Heueristik mussten die verschiedenen Issue-Slots berücksichtigt werden. Da jeden Adress-Dekoder zwei Source-Adressen aufweist, gibt es in diesem Fall vier Möglichkeiten der Allokation.
	\item gewichtete Hamming-Distanz\\
		blabla
	\item Lastkapazitaet\\
		blabla
	\item Hamming-Distanz und Lastkapazitaet\\
		blabla
	\item Adresssumme\\
		blabla
\end{itemize}
 
\subsection{Startpopulation}
Die Startpopulation besteht im Normalfall aus zufällig gewählten Genen. Hierbei werden nur Register verwendet die nicht bereits von physikalische Registern blockiert sind.
Um eine schnellere Konvergenz zu einem globalen Minimum zu gewährleisteten wird ein Gene der Startpopulation durch ein Heuristik-Algorithmus bestimmt. Dadurch wird bereits an einem lokalen Minimum gestartet und der genetische Algorithmus muss dies nicht selbst finden. 
Nachteilig ist hierbei jedoch das durch ungeeignete Parameter der Algorithmus bei dem bereits sehr starken lokalen Minimum stagniert und keine Verbesserung mehr finden kann. Aus diesem Grund sollte beim Start mit der Heueristik eine höhere Mutationswahrscheinlichkeit eingesetzt werden um dieses Minimum dennoch zu überwinden.

\subsection{dynamische Anpassung}
\newpage
\subsection{Algorithmus Modi}

-M -> Allocation Mode

	%Tabelle mit allen Modis 
	\begin{table}[htp]
		\centering
		\begin{tabular}{ccccccccc}
			\multicolumn{2}{l}{}                 & \multicolumn{7}{|l}{Modi}                                                               \\ 
			\multicolumn{2}{c}{Algorithmus-Konfig.}  & \multicolumn{1}{|c}{-E} & \multicolumn{1}{c}{-M} & \multicolumn{1}{c}{-R} & \multicolumn{1}{c}{-D} & \multicolumn{1}{c}{-H} & \multicolumn{1}{c}{-U} & \multicolumn{1}{c}{-o} \\ 
			\hline
		\multicolumn{2}{l}{Heuristik alt}  & \multicolumn{1}{|c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{1} \\
		\multicolumn{2}{l}{Heuristik neu}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{1} \\ 
		\multicolumn{2}{l}{Genetischer Algo. Hamming-Fitness}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{3} \\
			\multicolumn{2}{r}{}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{3} \\
			\multicolumn{2}{r}{Heuristik als Startpop.}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{3} \\
			\multicolumn{2}{r}{dynamischer Genetischer Algo.}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{3} \\
		\multicolumn{2}{l}{Genetischer Algo. Load-Fitness}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{3} \\ 
		\multicolumn{2}{l}{Genetischer Algo. Hamming+Load-Fitness}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{3}                     
		\end{tabular}
		\newline
		\caption{Algorithmus-Konfiguration}
	\end{table}

