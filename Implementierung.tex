\chapter{Implementierung}
\label{chap:Implementierung}

Nach genauerem betrachten der Formel für die dynamische Verlustleistung \ref{eq:dynVerlustleistung} hängt diese von vier Faktoren ab, Schaltaktivitäten,  Lastkapazität, Versorgungsspannung und der Frequenz. Die statische Verlustleistung wird nicht weiter betrachtet, da diese nur durch eine Veränderung der Hardware verbessert werden könnte. Dies ist jedoch nicht Teil dieser Arbeit. Da ebenfalls die Spannung und die Frequenz von der Architektur und anderen nicht beeinflussbaren Faktoren vorgegeben wurde kann auch an diesen Parametern nichts geändert werden. Im folgenden wird nun erst darauf eingegangen wie, durch Minimierung der Schaltaktivitäten, die Verlustleistung optimiert werden kann. Im Weiteren Verlauf des Textes wird dann ebenfalls der Einfluss der Lastkapazitäten überprüft.\\
Um in ein Register zu schreiben, muss eine geeignete Adresse an den Adressbus angelegt werden. Da es sich bei der Architektur um 32-bit-Register handelt muss hierfür eine 5-bit Adresse angelegt werden. Dieser Adressbus wird nun auf Schaltaktivität optimiert. Schreibt beispielsweise eine Anweisung an die Adresse Null und die nachfolgende Instruktion an die Adresse 31, so wäre dies der Worst-Case, da in diesem Fall alle 5-Bit umgeladen werden müssten. Befinden sich im Code jedoch virtuelle Register so können diese an beliebiger Stelle zugewiesen und somit die Adresse frei wählbar machen. Dadurch kann die Schaltaktivitäten der Leitungen verringert werden. Aus diesem Grund wurde zu Beginn eine Heuristik entwickelt bei der die Hammingdistanz der Adressleitungen minimiert wird.
\section{Heuristik}
\label{sec:Heuristik}
Um die Hammingdistanz zu berechnen werden die Adressen der letzten Anweisung gespeichert. Da die Architektur zwei Issue-Slots aufweist und diese auf beide Register-Files zugreifen können muss es dementsprechend vier Target-Adressleitungen geben(siehe Abbildung XXX). Wollen beide Instruktionen an das selbe Register-File schreiben, so werden entweder die alle zehn Adressleitungen für die Adressierung verwendet. Verwenden beiden Instruktionen unterschiedliche Register werden jeweils die unteren fünf Adressleitungen des jeweiligen Registers verwendet. Die Adressen bleiben solange in an der Adressleitung angelegt, bis ein neuer Befehl diese Leitungen benutzen muss. Die Distanz wird nun immer mit den zuletzt verwendeten Adressen bestimmt. 

\section{Genetischer Algorithmus}
\label{sec:genetischerAlgorithmus}
Die Gene des implementierten genetischen Algorithmus wurden so gewählt, dass diese die zu allokierenden Register repräsentieren. Die Anzahl der Gene hängt hierbei jeweils von der Menge der virtuellen Registern ab. Jedes Gen entspricht einem Mapping von virtuellen zu physikalischen Registern.
Die Populationsgröße wurde aus der Literatur [LLL] entnommen. Im Kapitel XXX wird der Einfluss der Population auf die Ergebnisse genauer untersucht. 


\subsection{Fitness-Funktion}
Da die Registerallokation dem Scheduling untergeordnet ist und von diesem aufgerufen wird, muss die Fitnessfunktion an die des Scheduling angepasst werden. Aus diesem Grund wurde zum einfacheren Vorgehen zwei Verschiedene Fitness-Funktionen implementiert. Zum einen der Wert der an die übergeordnete Funktion weitergegeben wird und zum Andern eine interne Fitness um die Ergebnisse zu evaluieren.
Der Übergabewert besteht lediglich aus der Anzahl der Register die nicht im Register-File allokiert werden konnten. Bei der internen Fitness-Funktion wurden mehrere Ansätze evaluiert.
\begin{itemize}
	\item Hamming-Distanz\\
		Als erste Variante wurde die Summe der Hamming-Distanzen als Fitness-Funktion verwendet. Hierzu wurden die Hammingdistanzen der Target- sowie Source-Register ermittelt. Wie im Falle der Heueristik mussten die verschiedenen Issue-Slots berücksichtigt werden. Da jeden Adress-Dekoder zwei Source-Adressen aufweist, gibt es in diesem Fall vier Möglichkeiten der Allokation.
	\item gewichtete Hamming-Distanz\\
		blabla
	\item Lastkapazitaet\\
		blabla
	\item Hamming-Distanz und Lastkapazitaet\\
		blabla
	\item Adresssumme\\
		blabla
\end{itemize}
 
\subsection{Startpopulation}
Die Startpopulation besteht im Normalfall aus zufällig gewählten Genen. Hierbei werden nur Register verwendet die nicht bereits von physikalische Registern blockiert sind.
Um eine schnellere Konvergenz zu einem globalen Minimum zu gewährleisteten wird ein Gene der Startpopulation durch ein Heuristik-Algorithmus bestimmt. Dadurch wird bereits an einem lokalen Minimum gestartet und der genetische Algorithmus muss dies nicht selbst finden. 
Nachteilig ist hierbei jedoch das durch ungeeignete Parameter der Algorithmus bei dem bereits sehr starken lokalen Minimum stagniert und keine Verbesserung mehr finden kann. Aus diesem Grund sollte beim Start mit der Heueristik eine höhere Mutationswahrscheinlichkeit eingesetzt werden um dieses Minimum dennoch zu überwinden.

\subsection{dynamische Anpassung}
Zu Beginn der Suche nach einer geeigneten Register-Alokation findet der Algorithmus
\newpage
\subsection{Algorithmus Modi}
\begin{itemize}
	 \setlength{\itemsep}{-6pt}
	\item-E -> Register Allokations-Modus Heuristik
			\begin{itemize}
				\setlength{\itemsep}{-4pt}
				\item Alt
				\item Neu
			\end{itemize}
	\item-M -> Register Allokations-Modus Genetischer Algorithmus
		\begin{itemize}
			\setlength{\itemsep}{-4pt}
			\item Hamming-Distanz
			\item Load
			\item Hamming*Load
		\end{itemize}
	\item-R -> Auswahl der Algorithmen
			\begin{itemize}
				\setlength{\itemsep}{-4pt}
				\item Genetischer Algorithmus
				\item Heuristik
			\end{itemize}
	\item-D -> dynamischer Genetischer Algorithmus
	\item-H -> Heuristik als Startgen
	\item-U -> Mutation-Modus
				\begin{itemize}
					\setlength{\itemsep}{-4pt}
					\item Mutation auf Crossover-Gen
					\item Mutation auf Zufalls-Gen
				\end{itemize}
	\item-o -> Optimierungsgrad
			\begin{itemize}
				\setlength{\itemsep}{-4pt}
				\item o1 List Scheduling
				\item o2 Genetisches Scheduling 20 Gene
				\item o3 Genetisches Scheduling 100 Gene
				\item o4 Genetisches Scheduling 200 Gene
			\end{itemize}
	
\end{itemize}


	%Tabelle mit allen Modis 
	\begin{table}[htp]
		\centering
		\begin{tabular}{ccccccccc}
			\multicolumn{2}{l}{}                 & \multicolumn{7}{|l}{Modi}                                                               \\ 
			\multicolumn{2}{c}{Algorithmus-Konfig.}  & \multicolumn{1}{|c}{-E} & \multicolumn{1}{c}{-M} & \multicolumn{1}{c}{-R} & \multicolumn{1}{c}{-D} & \multicolumn{1}{c}{-H} & \multicolumn{1}{c}{-U} & \multicolumn{1}{c}{-o} \\ 
			\hline
		\multicolumn{2}{l}{Heuristik alt}  & \multicolumn{1}{|c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{1} \\
		\multicolumn{2}{l}{Heuristik neu}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{X} & \multicolumn{1}{c}{1} \\ 
		\multicolumn{2}{l}{Genetischer Algo. Hamming-Fitness}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{2-4} \\
			\multicolumn{2}{r}{}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{2-4} \\
			\multicolumn{2}{r}{Heuristik als Startpop.}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{2-4} \\
			\multicolumn{2}{r}{dynamischer Genetischer Algo.}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{2-4} \\
		\multicolumn{2}{l}{Genetischer Algo. Load-Fitness}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{2-4} \\ 
		\multicolumn{2}{l}{Genetischer Algo. Hamming*Load-Fitness}  & \multicolumn{1}{|c}{1} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{0} & \multicolumn{1}{c}{2-4}                     
		\end{tabular}
		\newline
		\caption{Algorithmus-Konfiguration}
	\end{table}

\subsection{Glitches}
Die fuer die Schreib- und Lesezugriffe verwendeten Adressen werden jeweils zwischen den Takten angelegt um so zu gewaehrleisten, dass diese mit der steigenden Taktflanke auch uebernommen werden koennen. Die Auswahl der Ports wird ueber Enablesignale geregelt. Werden beispielwesie zwei Instruktionen verwendet die beide an Register-File 1 schreiben, so werden die Adressen an die jeweiligen Portsangelegt und sobald diese zu verfuegung stehen von den Enable-Signalen freigegeben.\\
Nun tritt jedoch das Problem auf, dass Adress und Enable Signal nicht zeitgleich umschalten. Dies lieg daran, dass die benoetigten Enable-Signale aufwendig berechnet werden, und dies eine kurze Verzoegerung nachsich zieht. Aus diesem Grund liegt die bereits geaenderte Adresse kurze Zeit an dem falschen Adressport an. Sobald das Enable-Signal berechnet wurde, werden die richtigen Adressen angelegt. Dieses Szenario tritt lediglich auf, wenn ein Wechsel in den Enable-Signalen und sich somit die Herkunft der Adressen aendert. Das Beschriebene Problem verursacht eine Erhoehung der Schaltaktivitaet auf den Adressleitungen und somit auch eine steigende Verlustleistung um XXX \%
Um diesem Effekt gegenzuwirken wurde eine zweite Pipline-Stufe eingebaut. Durch die Verzoegerung der Signale ist garantiert das die Adressen erst dann an den entsprechenden Ports anliegen wenn diese benoetigt werden. 

